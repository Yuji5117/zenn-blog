---
title: "JavaScriptを深く知る旅 #2：値渡し・参照渡しって？"
emoji: "😇"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react", "nextjs", "nodejs", "typescript", "javascript"]
published: false
---

## はじめに
JavaScriptの基礎を学ぶために、今回は第2回として「値渡し」と「参照渡し」についてまとめていきます。
この概念を理解しておくと、たとえばReactでstateを更新したのに再レンダリングされないといった問題にも、仕組みから納得して対処できるようになります。



## 値渡しってなに？

「値渡し」とは、変数に格納されている値そのもののコピーを渡すことを指します。
対象となるのは、`string`、`number`、`boolean` などのプリミティブな値です。

例えば、変数 `x` を変数 `y` に代入し、その後 `y` の値を変更しても、`x` の値には影響がありません。
これは、代入時に値のコピーが渡されているためで、`x` の**元の値とは別物として扱われる**からです。

イメージとしては、ある証明書のコピーを渡しているようなもの。
受け取ったコピーにメモを書いたり、折り目をつけたりしても、元の証明書には一切影響がないという感覚です。

```
let x = "Hello!!"
let y = x

y = "Change!!"

console.log(x) // "Hello!!" <- 値は変わらない
```



一方、「参照渡し」は、値渡しとは異なる挙動を示します。
対象となるのは、オブジェクト・配列・関数などの**非プリミティブ型（オブジェクト型）**です。

たとえば、変数 `x` にオブジェクトを代入し、それを変数 `y` にコピーしたあと、`y` の中身を変更すると、`x` の中身も一緒に変わってしまいます。
これは、`x` と `y` が同じ参照（メモリ上の同じ場所）を見ているためです。

つまり、値そのものをコピーして渡すのではなく、「どこにあるか（参照先）」の情報が渡されているのが「参照渡し」です。
先ほどの証明書の例で言うと、証明書そのものを渡すのではなく、「保管場所の地図」を渡すイメージです。
保管場所を知っていれば、誰でもその場所に行けて、内容を変更できる。
そのため、どちらの変数からアクセスしても、同じオブジェクトに影響を与えることになります。

```js
let x = { message: "Hello!!" };
let y = x;

y.message = "Change!!";

console.log(x.message); // "Change!!" ← xの中身も変わってしまう

```

この三勝私には、浅いコピーと深いコピーが存在します。
それぞれを見ていきましょう

### 浅いコピー（shallow copy）
浅いコピー（shallow copy）とは、**ネストされたオブジェクトや配列の最初の階層だけをコピーする**ことを指します。

以下のコードでは、ネストされたオブジェクトを持つ変数を、別の変数に代入しています。
このとき、ネストされていないプロパティ（第一階層）を変更しても、元のオブジェクトには影響がありません。これは、その部分が値としてコピーされているためです。

しかし、ネストされた部分（オブジェクトの中のオブジェクトなど）を変更するとどうなるでしょうか？
その答えは、**元の変数の値も一緒に変更されてしまう**、です。

これは、浅いコピーではネストされた内部の値まではコピーされず、参照（アドレス）だけが渡されているためです。
つまり、**「外側はコピーされたけれど、中身は共有されたまま」**になっているということです。

```js

const original = {
  name: "Taro",
  address: {
    city: "Tokyo",
  },
};

const copy = { ...original };

// 浅い部分を変更
copy.name = "Bob";
console.log(original.name); // "Taro" → 影響なし

// ネストされた部分を変更
copy.address.city = "Osaka";
console.log(original.address.city); // "Osaka" → 元のオブジェクトも変わってしまう

```


### 深いコピー（deep copy）



## React開発での注意点

### useStateでの更新時

### useEffectでの依存配列

### React.memoでの最適化

オブジェクトの中身を変更して、その変更を反映させたいとき

## まとめ